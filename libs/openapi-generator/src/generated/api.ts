/* tslint:disable */
/* eslint-disable */
/**
 * English
 * English API documents
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   *
   * @type {object}
   * @memberof ApiError
   */
  error?: object | null;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  traceId: string;
  /**
   *
   * @type {number}
   * @memberof ApiError
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  message: string;
  /**
   *
   * @type {Array<ValidationExceptionResponse>}
   * @memberof ApiError
   */
  validationErrors: Array<ValidationExceptionResponse>;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface AppApiErrorResponse
 */
export interface AppApiErrorResponse {
  /**
   *
   * @type {ApiError}
   * @memberof AppApiErrorResponse
   */
  error: ApiError;
  /**
   *
   * @type {string}
   * @memberof AppApiErrorResponse
   */
  message: string;
}
/**
 *
 * @export
 * @interface AppApiPaginatedResponse
 */
export interface AppApiPaginatedResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof AppApiPaginatedResponse
   */
  data: Array<string>;
  /**
   *
   * @type {Pagination}
   * @memberof AppApiPaginatedResponse
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof AppApiPaginatedResponse
   */
  message: string;
}
/**
 *
 * @export
 * @interface AppApiSuccessResponse
 */
export interface AppApiSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof AppApiSuccessResponse
   */
  message: string;
}
/**
 *
 * @export
 * @interface AssignmentCreate200Response
 */
export interface AssignmentCreate200Response {
  /**
   *
   * @type {string}
   * @memberof AssignmentCreate200Response
   */
  message: string;
  /**
   *
   * @type {AssignmentResponse}
   * @memberof AssignmentCreate200Response
   */
  data: AssignmentResponse;
}
/**
 *
 * @export
 * @interface AssignmentCreate200ResponseAllOf
 */
export interface AssignmentCreate200ResponseAllOf {
  /**
   *
   * @type {AssignmentResponse}
   * @memberof AssignmentCreate200ResponseAllOf
   */
  data?: AssignmentResponse;
}
/**
 *
 * @export
 * @interface AssignmentList200Response
 */
export interface AssignmentList200Response {
  /**
   *
   * @type {Array<AssignmentResponse>}
   * @memberof AssignmentList200Response
   */
  data: Array<AssignmentResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof AssignmentList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof AssignmentList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface AssignmentList200ResponseAllOf
 */
export interface AssignmentList200ResponseAllOf {
  /**
   *
   * @type {Array<AssignmentResponse>}
   * @memberof AssignmentList200ResponseAllOf
   */
  data?: Array<AssignmentResponse>;
}
/**
 *
 * @export
 * @interface AssignmentResponse
 */
export interface AssignmentResponse {
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof AssignmentResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof AssignmentResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  __typename?: AssignmentResponseTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof AssignmentResponse
   */
  lesson_id: number;
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AssignmentResponse
   */
  description: string;
}

export const AssignmentResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type AssignmentResponseTypenameEnum =
  (typeof AssignmentResponseTypenameEnum)[keyof typeof AssignmentResponseTypenameEnum];

/**
 *
 * @export
 * @interface AverageResponse
 */
export interface AverageResponse {
  /**
   *
   * @type {number}
   * @memberof AverageResponse
   */
  rate_point: number;
}
/**
 *
 * @export
 * @interface CategoryList200Response
 */
export interface CategoryList200Response {
  /**
   *
   * @type {Array<CategoryResponse>}
   * @memberof CategoryList200Response
   */
  data: Array<CategoryResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof CategoryList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof CategoryList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface CategoryList200ResponseAllOf
 */
export interface CategoryList200ResponseAllOf {
  /**
   *
   * @type {Array<CategoryResponse>}
   * @memberof CategoryList200ResponseAllOf
   */
  data?: Array<CategoryResponse>;
}
/**
 *
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
  /**
   *
   * @type {string}
   * @memberof CategoryResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof CategoryResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CategoryResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CategoryResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof CategoryResponse
   */
  __typename?: CategoryResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof CategoryResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CategoryResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CategoryResponse
   */
  slug: string;
}

export const CategoryResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type CategoryResponseTypenameEnum =
  (typeof CategoryResponseTypenameEnum)[keyof typeof CategoryResponseTypenameEnum];

/**
 *
 * @export
 * @interface CourseCreate200Response
 */
export interface CourseCreate200Response {
  /**
   *
   * @type {string}
   * @memberof CourseCreate200Response
   */
  message: string;
  /**
   *
   * @type {CourseResponse}
   * @memberof CourseCreate200Response
   */
  data: CourseResponse;
}
/**
 *
 * @export
 * @interface CourseCreate200ResponseAllOf
 */
export interface CourseCreate200ResponseAllOf {
  /**
   *
   * @type {CourseResponse}
   * @memberof CourseCreate200ResponseAllOf
   */
  data?: CourseResponse;
}
/**
 *
 * @export
 * @interface CourseDelete200Response
 */
export interface CourseDelete200Response {
  /**
   *
   * @type {string}
   * @memberof CourseDelete200Response
   */
  message: string;
  /**
   *
   * @type {DeleteResponse}
   * @memberof CourseDelete200Response
   */
  data: DeleteResponse;
}
/**
 *
 * @export
 * @interface CourseDelete200ResponseAllOf
 */
export interface CourseDelete200ResponseAllOf {
  /**
   *
   * @type {DeleteResponse}
   * @memberof CourseDelete200ResponseAllOf
   */
  data?: DeleteResponse;
}
/**
 *
 * @export
 * @interface CourseDetailResponse
 */
export interface CourseDetailResponse {
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CourseDetailResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CourseDetailResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  __typename?: CourseDetailResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof CourseDetailResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof CourseDetailResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof CourseDetailResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof CourseDetailResponse
   */
  mode: number;
  /**
   *
   * @type {number}
   * @memberof CourseDetailResponse
   */
  type: number;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof CourseDetailResponse
   */
  cover: StoredFileResponse;
  /**
   *
   * @type {number}
   * @memberof CourseDetailResponse
   */
  administrator_id: number;
  /**
   *
   * @type {UserResponse}
   * @memberof CourseDetailResponse
   */
  administrator: UserResponse;
  /**
   *
   * @type {CoursePriceResponse}
   * @memberof CourseDetailResponse
   */
  course_price: CoursePriceResponse;
  /**
   *
   * @type {Array<SectionFullResponse>}
   * @memberof CourseDetailResponse
   */
  sections: Array<SectionFullResponse>;
  /**
   *
   * @type {Array<TopicResponse>}
   * @memberof CourseDetailResponse
   */
  topics: Array<TopicResponse>;
  /**
   *
   * @type {Array<UserResponse>}
   * @memberof CourseDetailResponse
   */
  students: Array<UserResponse>;
}

export const CourseDetailResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type CourseDetailResponseTypenameEnum =
  (typeof CourseDetailResponseTypenameEnum)[keyof typeof CourseDetailResponseTypenameEnum];

/**
 *
 * @export
 * @interface CourseFindCourseLearnings200Response
 */
export interface CourseFindCourseLearnings200Response {
  /**
   *
   * @type {Array<CourseDetailResponse>}
   * @memberof CourseFindCourseLearnings200Response
   */
  data: Array<CourseDetailResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof CourseFindCourseLearnings200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof CourseFindCourseLearnings200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface CourseFindCourseLearnings200ResponseAllOf
 */
export interface CourseFindCourseLearnings200ResponseAllOf {
  /**
   *
   * @type {Array<CourseDetailResponse>}
   * @memberof CourseFindCourseLearnings200ResponseAllOf
   */
  data?: Array<CourseDetailResponse>;
}
/**
 *
 * @export
 * @interface CourseFindOne200Response
 */
export interface CourseFindOne200Response {
  /**
   *
   * @type {string}
   * @memberof CourseFindOne200Response
   */
  message: string;
  /**
   *
   * @type {CourseDetailResponse}
   * @memberof CourseFindOne200Response
   */
  data: CourseDetailResponse;
}
/**
 *
 * @export
 * @interface CourseFindOne200ResponseAllOf
 */
export interface CourseFindOne200ResponseAllOf {
  /**
   *
   * @type {CourseDetailResponse}
   * @memberof CourseFindOne200ResponseAllOf
   */
  data?: CourseDetailResponse;
}
/**
 *
 * @export
 * @interface CourseList200Response
 */
export interface CourseList200Response {
  /**
   *
   * @type {Array<CourseResponse>}
   * @memberof CourseList200Response
   */
  data: Array<CourseResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof CourseList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof CourseList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface CourseList200ResponseAllOf
 */
export interface CourseList200ResponseAllOf {
  /**
   *
   * @type {Array<CourseResponse>}
   * @memberof CourseList200ResponseAllOf
   */
  data?: Array<CourseResponse>;
}
/**
 *
 * @export
 * @interface CoursePriceResponse
 */
export interface CoursePriceResponse {
  /**
   *
   * @type {string}
   * @memberof CoursePriceResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof CoursePriceResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CoursePriceResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CoursePriceResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof CoursePriceResponse
   */
  __typename?: CoursePriceResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof CoursePriceResponse
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof CoursePriceResponse
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof CoursePriceResponse
   */
  price: number;
  /**
   *
   * @type {number}
   * @memberof CoursePriceResponse
   */
  discount: number;
}

export const CoursePriceResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type CoursePriceResponseTypenameEnum =
  (typeof CoursePriceResponseTypenameEnum)[keyof typeof CoursePriceResponseTypenameEnum];

/**
 *
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CourseResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof CourseResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  __typename?: CourseResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof CourseResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof CourseResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof CourseResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof CourseResponse
   */
  mode: number;
  /**
   *
   * @type {number}
   * @memberof CourseResponse
   */
  type: number;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof CourseResponse
   */
  cover: StoredFileResponse;
  /**
   *
   * @type {number}
   * @memberof CourseResponse
   */
  administrator_id: number;
  /**
   *
   * @type {UserResponse}
   * @memberof CourseResponse
   */
  administrator: UserResponse;
  /**
   *
   * @type {CoursePriceResponse}
   * @memberof CourseResponse
   */
  course_price: CoursePriceResponse;
}

export const CourseResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type CourseResponseTypenameEnum =
  (typeof CourseResponseTypenameEnum)[keyof typeof CourseResponseTypenameEnum];

/**
 *
 * @export
 * @interface CourseStats200Response
 */
export interface CourseStats200Response {
  /**
   *
   * @type {string}
   * @memberof CourseStats200Response
   */
  message: string;
  /**
   *
   * @type {CourseStatsResponse}
   * @memberof CourseStats200Response
   */
  data: CourseStatsResponse;
}
/**
 *
 * @export
 * @interface CourseStats200ResponseAllOf
 */
export interface CourseStats200ResponseAllOf {
  /**
   *
   * @type {CourseStatsResponse}
   * @memberof CourseStats200ResponseAllOf
   */
  data?: CourseStatsResponse;
}
/**
 *
 * @export
 * @interface CourseStatsResponse
 */
export interface CourseStatsResponse {
  /**
   *
   * @type {number}
   * @memberof CourseStatsResponse
   */
  total_course: number;
  /**
   *
   * @type {number}
   * @memberof CourseStatsResponse
   */
  total_video: number;
  /**
   *
   * @type {number}
   * @memberof CourseStatsResponse
   */
  total_time: number;
}
/**
 *
 * @export
 * @interface CreateAssignmentDto
 */
export interface CreateAssignmentDto {
  /**
   *
   * @type {number}
   * @memberof CreateAssignmentDto
   */
  lesson_id: number;
  /**
   *
   * @type {string}
   * @memberof CreateAssignmentDto
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof CreateAssignmentDto
   */
  description: string;
}
/**
 *
 * @export
 * @interface CreateDiscussionDto
 */
export interface CreateDiscussionDto {
  /**
   *
   * @type {number}
   * @memberof CreateDiscussionDto
   */
  lesson_id: number;
  /**
   *
   * @type {string}
   * @memberof CreateDiscussionDto
   */
  description: string;
}
/**
 *
 * @export
 * @interface CreateSectionDto
 */
export interface CreateSectionDto {
  /**
   *
   * @type {number}
   * @memberof CreateSectionDto
   */
  course_id: number;
  /**
   *
   * @type {string}
   * @memberof CreateSectionDto
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof CreateSectionDto
   */
  description: string;
}
/**
 *
 * @export
 * @interface DeleteResponse
 */
export interface DeleteResponse {
  /**
   *
   * @type {number}
   * @memberof DeleteResponse
   */
  id: number;
}
/**
 *
 * @export
 * @interface DeleteUuidResponse
 */
export interface DeleteUuidResponse {
  /**
   *
   * @type {string}
   * @memberof DeleteUuidResponse
   */
  id: string;
}
/**
 *
 * @export
 * @interface DiscussionCreate200Response
 */
export interface DiscussionCreate200Response {
  /**
   *
   * @type {string}
   * @memberof DiscussionCreate200Response
   */
  message: string;
  /**
   *
   * @type {DiscussionResponse}
   * @memberof DiscussionCreate200Response
   */
  data: DiscussionResponse;
}
/**
 *
 * @export
 * @interface DiscussionCreate200ResponseAllOf
 */
export interface DiscussionCreate200ResponseAllOf {
  /**
   *
   * @type {DiscussionResponse}
   * @memberof DiscussionCreate200ResponseAllOf
   */
  data?: DiscussionResponse;
}
/**
 *
 * @export
 * @interface DiscussionDelete200Response
 */
export interface DiscussionDelete200Response {
  /**
   *
   * @type {string}
   * @memberof DiscussionDelete200Response
   */
  message: string;
  /**
   *
   * @type {DeleteUuidResponse}
   * @memberof DiscussionDelete200Response
   */
  data: DeleteUuidResponse;
}
/**
 *
 * @export
 * @interface DiscussionDelete200ResponseAllOf
 */
export interface DiscussionDelete200ResponseAllOf {
  /**
   *
   * @type {DeleteUuidResponse}
   * @memberof DiscussionDelete200ResponseAllOf
   */
  data?: DeleteUuidResponse;
}
/**
 *
 * @export
 * @interface DiscussionList200Response
 */
export interface DiscussionList200Response {
  /**
   *
   * @type {Array<DiscussionResponse>}
   * @memberof DiscussionList200Response
   */
  data: Array<DiscussionResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof DiscussionList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof DiscussionList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface DiscussionList200ResponseAllOf
 */
export interface DiscussionList200ResponseAllOf {
  /**
   *
   * @type {Array<DiscussionResponse>}
   * @memberof DiscussionList200ResponseAllOf
   */
  data?: Array<DiscussionResponse>;
}
/**
 *
 * @export
 * @interface DiscussionResponse
 */
export interface DiscussionResponse {
  /**
   *
   * @type {string}
   * @memberof DiscussionResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof DiscussionResponse
   */
  updated_at: string;
  /**
   *
   * @type {LearningRequestResponseRequester}
   * @memberof DiscussionResponse
   */
  creator: LearningRequestResponseRequester | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof DiscussionResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof DiscussionResponse
   */
  __typename?: DiscussionResponseTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof DiscussionResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DiscussionResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DiscussionResponse
   */
  lesson_id: number;
}

export const DiscussionResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type DiscussionResponseTypenameEnum =
  (typeof DiscussionResponseTypenameEnum)[keyof typeof DiscussionResponseTypenameEnum];

/**
 *
 * @export
 * @interface FcmMessageOptions
 */
export interface FcmMessageOptions {
  /**
   *
   * @type {string}
   * @memberof FcmMessageOptions
   */
  link?: string;
}
/**
 *
 * @export
 * @interface FcmMessageResponse
 */
export interface FcmMessageResponse {
  /**
   *
   * @type {FcmNotificationPayloadResponse}
   * @memberof FcmMessageResponse
   */
  notification: FcmNotificationPayloadResponse;
  /**
   *
   * @type {FcmMessageWebpush}
   * @memberof FcmMessageResponse
   */
  webpush?: FcmMessageWebpush;
}
/**
 *
 * @export
 * @interface FcmMessageWebpush
 */
export interface FcmMessageWebpush {
  /**
   *
   * @type {FcmMessageOptions}
   * @memberof FcmMessageWebpush
   */
  fcmOptions?: FcmMessageOptions;
}
/**
 *
 * @export
 * @interface FcmNotificationPayloadResponse
 */
export interface FcmNotificationPayloadResponse {
  /**
   *
   * @type {string}
   * @memberof FcmNotificationPayloadResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof FcmNotificationPayloadResponse
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof FcmNotificationPayloadResponse
   */
  link: string;
  /**
   *
   * @type {string}
   * @memberof FcmNotificationPayloadResponse
   */
  imageUrl?: string;
}
/**
 *
 * @export
 * @interface GoogleLogin200Response
 */
export interface GoogleLogin200Response {
  /**
   *
   * @type {string}
   * @memberof GoogleLogin200Response
   */
  message: string;
  /**
   *
   * @type {GoogleLoginResponse}
   * @memberof GoogleLogin200Response
   */
  data: GoogleLoginResponse;
}
/**
 *
 * @export
 * @interface GoogleLogin200ResponseAllOf
 */
export interface GoogleLogin200ResponseAllOf {
  /**
   *
   * @type {GoogleLoginResponse}
   * @memberof GoogleLogin200ResponseAllOf
   */
  data?: GoogleLoginResponse;
}
/**
 *
 * @export
 * @interface GoogleLoginDto
 */
export interface GoogleLoginDto {
  /**
   *
   * @type {string}
   * @memberof GoogleLoginDto
   */
  credential: string;
}
/**
 *
 * @export
 * @interface GoogleLoginResponse
 */
export interface GoogleLoginResponse {
  /**
   *
   * @type {string}
   * @memberof GoogleLoginResponse
   */
  token: string;
}
/**
 *
 * @export
 * @interface LearningRequestDto
 */
export interface LearningRequestDto {
  /**
   *
   * @type {number}
   * @memberof LearningRequestDto
   */
  course_id: number;
}
/**
 *
 * @export
 * @interface LearningRequestList200Response
 */
export interface LearningRequestList200Response {
  /**
   *
   * @type {Array<LearningRequestResponse>}
   * @memberof LearningRequestList200Response
   */
  data: Array<LearningRequestResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof LearningRequestList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof LearningRequestList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface LearningRequestList200ResponseAllOf
 */
export interface LearningRequestList200ResponseAllOf {
  /**
   *
   * @type {Array<LearningRequestResponse>}
   * @memberof LearningRequestList200ResponseAllOf
   */
  data?: Array<LearningRequestResponse>;
}
/**
 *
 * @export
 * @interface LearningRequestRequest200Response
 */
export interface LearningRequestRequest200Response {
  /**
   *
   * @type {string}
   * @memberof LearningRequestRequest200Response
   */
  message: string;
  /**
   *
   * @type {LearningRequestResponse}
   * @memberof LearningRequestRequest200Response
   */
  data: LearningRequestResponse;
}
/**
 *
 * @export
 * @interface LearningRequestRequest200ResponseAllOf
 */
export interface LearningRequestRequest200ResponseAllOf {
  /**
   *
   * @type {LearningRequestResponse}
   * @memberof LearningRequestRequest200ResponseAllOf
   */
  data?: LearningRequestResponse;
}
/**
 *
 * @export
 * @interface LearningRequestResponse
 */
export interface LearningRequestResponse {
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponse
   */
  __typename?: LearningRequestResponseTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponse
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponse
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponse
   */
  requester_id: number;
  /**
   *
   * @type {LearningRequestResponseCourse}
   * @memberof LearningRequestResponse
   */
  course: LearningRequestResponseCourse | null;
  /**
   *
   * @type {LearningRequestResponseRequester}
   * @memberof LearningRequestResponse
   */
  requester: LearningRequestResponseRequester | null;
}

export const LearningRequestResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type LearningRequestResponseTypenameEnum =
  (typeof LearningRequestResponseTypenameEnum)[keyof typeof LearningRequestResponseTypenameEnum];

/**
 *
 * @export
 * @interface LearningRequestResponseCourse
 */
export interface LearningRequestResponseCourse {
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponseCourse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponseCourse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  __typename?: LearningRequestResponseCourseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseCourse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseCourse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseCourse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseCourse
   */
  mode: number;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseCourse
   */
  type: number;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof LearningRequestResponseCourse
   */
  cover: StoredFileResponse;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseCourse
   */
  administrator_id: number;
  /**
   *
   * @type {UserResponse}
   * @memberof LearningRequestResponseCourse
   */
  administrator: UserResponse;
  /**
   *
   * @type {CoursePriceResponse}
   * @memberof LearningRequestResponseCourse
   */
  course_price: CoursePriceResponse;
}

export const LearningRequestResponseCourseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type LearningRequestResponseCourseTypenameEnum =
  (typeof LearningRequestResponseCourseTypenameEnum)[keyof typeof LearningRequestResponseCourseTypenameEnum];

/**
 *
 * @export
 * @interface LearningRequestResponseRequester
 */
export interface LearningRequestResponseRequester {
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseRequester
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  google_id: string | null;
  /**
   *
   * @type {number}
   * @memberof LearningRequestResponseRequester
   */
  role_id: number;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  avatar_id: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  phone: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  facebook: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  github: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  twitter: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  job: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  description: string | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponseRequester
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LearningRequestResponseRequester
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof LearningRequestResponseRequester
   */
  __typename?: LearningRequestResponseRequesterTypenameEnum;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof LearningRequestResponseRequester
   */
  avatar: StoredFileResponse;
  /**
   *
   * @type {RoleResponse}
   * @memberof LearningRequestResponseRequester
   */
  role: RoleResponse;
  /**
   *
   * @type {WalletResponse}
   * @memberof LearningRequestResponseRequester
   */
  wallet: WalletResponse;
}

export const LearningRequestResponseRequesterTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type LearningRequestResponseRequesterTypenameEnum =
  (typeof LearningRequestResponseRequesterTypenameEnum)[keyof typeof LearningRequestResponseRequesterTypenameEnum];

/**
 *
 * @export
 * @interface LessonResponse
 */
export interface LessonResponse {
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LessonResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof LessonResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  __typename?: LessonResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof LessonResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof LessonResponse
   */
  video_id: string;
  /**
   *
   * @type {number}
   * @memberof LessonResponse
   */
  section_id: number;
  /**
   *
   * @type {number}
   * @memberof LessonResponse
   */
  order: number;
  /**
   *
   * @type {TopicStatResponseCover}
   * @memberof LessonResponse
   */
  video: TopicStatResponseCover | null;
  /**
   *
   * @type {number}
   * @memberof LessonResponse
   */
  type: number;
  /**
   *
   * @type {number}
   * @memberof LessonResponse
   */
  time: number;
}

export const LessonResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type LessonResponseTypenameEnum =
  (typeof LessonResponseTypenameEnum)[keyof typeof LessonResponseTypenameEnum];

/**
 *
 * @export
 * @interface MarkNotificationResponse
 */
export interface MarkNotificationResponse {
  /**
   *
   * @type {string}
   * @memberof MarkNotificationResponse
   */
  message: string;
}
/**
 *
 * @export
 * @interface NotificationPayloadResponse
 */
export interface NotificationPayloadResponse {
  /**
   *
   * @type {NotificationRequestDataPayload}
   * @memberof NotificationPayloadResponse
   */
  data: NotificationRequestDataPayload;
  /**
   *
   * @type {string}
   * @memberof NotificationPayloadResponse
   */
  type: NotificationPayloadResponseTypeEnum;
  /**
   *
   * @type {number}
   * @memberof NotificationPayloadResponse
   */
  to: number;
}

export const NotificationPayloadResponseTypeEnum = {
  LearningRequests: 'learning-requests',
  TechingRequests: 'teching-requests',
} as const;

export type NotificationPayloadResponseTypeEnum =
  (typeof NotificationPayloadResponseTypeEnum)[keyof typeof NotificationPayloadResponseTypeEnum];

/**
 *
 * @export
 * @interface NotificationRequestDataPayload
 */
export interface NotificationRequestDataPayload {
  /**
   *
   * @type {string}
   * @memberof NotificationRequestDataPayload
   */
  request_id: string;
}
/**
 *
 * @export
 * @interface NotificationResponse
 */
export interface NotificationResponse {
  /**
   *
   * @type {string}
   * @memberof NotificationResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof NotificationResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof NotificationResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof NotificationResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof NotificationResponse
   */
  __typename?: NotificationResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof NotificationResponse
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof NotificationResponse
   */
  user_id: number | null;
  /**
   *
   * @type {NotificationPayloadResponse}
   * @memberof NotificationResponse
   */
  payload: NotificationPayloadResponse;
  /**
   *
   * @type {FcmMessageResponse}
   * @memberof NotificationResponse
   */
  fcm_message: FcmMessageResponse;
  /**
   *
   * @type {number}
   * @memberof NotificationResponse
   */
  type: NotificationResponseTypeEnum;
  /**
   *
   * @type {number}
   * @memberof NotificationResponse
   */
  status: NotificationResponseStatusEnum;
}

export const NotificationResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type NotificationResponseTypenameEnum =
  (typeof NotificationResponseTypenameEnum)[keyof typeof NotificationResponseTypenameEnum];
export const NotificationResponseTypeEnum = {
  NUMBER_1: 1,
} as const;

export type NotificationResponseTypeEnum =
  (typeof NotificationResponseTypeEnum)[keyof typeof NotificationResponseTypeEnum];
export const NotificationResponseStatusEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type NotificationResponseStatusEnum =
  (typeof NotificationResponseStatusEnum)[keyof typeof NotificationResponseStatusEnum];

/**
 *
 * @export
 * @interface NotificationSubscriptionCreate200Response
 */
export interface NotificationSubscriptionCreate200Response {
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionCreate200Response
   */
  message: string;
  /**
   *
   * @type {NotificationSubscriptionResponse}
   * @memberof NotificationSubscriptionCreate200Response
   */
  data: NotificationSubscriptionResponse;
}
/**
 *
 * @export
 * @interface NotificationSubscriptionCreate200ResponseAllOf
 */
export interface NotificationSubscriptionCreate200ResponseAllOf {
  /**
   *
   * @type {NotificationSubscriptionResponse}
   * @memberof NotificationSubscriptionCreate200ResponseAllOf
   */
  data?: NotificationSubscriptionResponse;
}
/**
 *
 * @export
 * @interface NotificationSubscriptionCreateDto
 */
export interface NotificationSubscriptionCreateDto {
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionCreateDto
   */
  token: string;
}
/**
 *
 * @export
 * @interface NotificationSubscriptionResponse
 */
export interface NotificationSubscriptionResponse {
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof NotificationSubscriptionResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof NotificationSubscriptionResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionResponse
   */
  __typename?: NotificationSubscriptionResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof NotificationSubscriptionResponse
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof NotificationSubscriptionResponse
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionResponse
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof NotificationSubscriptionResponse
   */
  last_active: string;
  /**
   *
   * @type {UserBasicResponse}
   * @memberof NotificationSubscriptionResponse
   */
  user: UserBasicResponse;
  /**
   *
   * @type {number}
   * @memberof NotificationSubscriptionResponse
   */
  status: NotificationSubscriptionResponseStatusEnum;
}

export const NotificationSubscriptionResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type NotificationSubscriptionResponseTypenameEnum =
  (typeof NotificationSubscriptionResponseTypenameEnum)[keyof typeof NotificationSubscriptionResponseTypenameEnum];
export const NotificationSubscriptionResponseStatusEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type NotificationSubscriptionResponseStatusEnum =
  (typeof NotificationSubscriptionResponseStatusEnum)[keyof typeof NotificationSubscriptionResponseStatusEnum];

/**
 *
 * @export
 * @interface NotificationsList200Response
 */
export interface NotificationsList200Response {
  /**
   *
   * @type {Array<NotificationResponse>}
   * @memberof NotificationsList200Response
   */
  data: Array<NotificationResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof NotificationsList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof NotificationsList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface NotificationsList200ResponseAllOf
 */
export interface NotificationsList200ResponseAllOf {
  /**
   *
   * @type {Array<NotificationResponse>}
   * @memberof NotificationsList200ResponseAllOf
   */
  data?: Array<NotificationResponse>;
}
/**
 *
 * @export
 * @interface NotificationsReadAllNotification200Response
 */
export interface NotificationsReadAllNotification200Response {
  /**
   *
   * @type {string}
   * @memberof NotificationsReadAllNotification200Response
   */
  message: string;
  /**
   *
   * @type {MarkNotificationResponse}
   * @memberof NotificationsReadAllNotification200Response
   */
  data: MarkNotificationResponse;
}
/**
 *
 * @export
 * @interface NotificationsReadAllNotification200ResponseAllOf
 */
export interface NotificationsReadAllNotification200ResponseAllOf {
  /**
   *
   * @type {MarkNotificationResponse}
   * @memberof NotificationsReadAllNotification200ResponseAllOf
   */
  data?: MarkNotificationResponse;
}
/**
 *
 * @export
 * @interface NotificationsReadNotification200Response
 */
export interface NotificationsReadNotification200Response {
  /**
   *
   * @type {string}
   * @memberof NotificationsReadNotification200Response
   */
  message: string;
  /**
   *
   * @type {NotificationResponse}
   * @memberof NotificationsReadNotification200Response
   */
  data: NotificationResponse;
}
/**
 *
 * @export
 * @interface NotificationsReadNotification200ResponseAllOf
 */
export interface NotificationsReadNotification200ResponseAllOf {
  /**
   *
   * @type {NotificationResponse}
   * @memberof NotificationsReadNotification200ResponseAllOf
   */
  data?: NotificationResponse;
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  lastPage: number;
}
/**
 *
 * @export
 * @interface RateDto
 */
export interface RateDto {
  /**
   *
   * @type {number}
   * @memberof RateDto
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof RateDto
   */
  point: number;
  /**
   *
   * @type {string}
   * @memberof RateDto
   */
  comment: string;
}
/**
 *
 * @export
 * @interface RatingCoursesGetPoint200Response
 */
export interface RatingCoursesGetPoint200Response {
  /**
   *
   * @type {Array<AverageResponse>}
   * @memberof RatingCoursesGetPoint200Response
   */
  data: Array<AverageResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof RatingCoursesGetPoint200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof RatingCoursesGetPoint200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface RatingCoursesGetPoint200ResponseAllOf
 */
export interface RatingCoursesGetPoint200ResponseAllOf {
  /**
   *
   * @type {Array<AverageResponse>}
   * @memberof RatingCoursesGetPoint200ResponseAllOf
   */
  data?: Array<AverageResponse>;
}
/**
 *
 * @export
 * @interface RatingCoursesList200Response
 */
export interface RatingCoursesList200Response {
  /**
   *
   * @type {Array<RatingResponse>}
   * @memberof RatingCoursesList200Response
   */
  data: Array<RatingResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof RatingCoursesList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof RatingCoursesList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface RatingCoursesList200ResponseAllOf
 */
export interface RatingCoursesList200ResponseAllOf {
  /**
   *
   * @type {Array<RatingResponse>}
   * @memberof RatingCoursesList200ResponseAllOf
   */
  data?: Array<RatingResponse>;
}
/**
 *
 * @export
 * @interface RatingResponse
 */
export interface RatingResponse {
  /**
   *
   * @type {string}
   * @memberof RatingResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof RatingResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof RatingResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof RatingResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof RatingResponse
   */
  __typename?: RatingResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof RatingResponse
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof RatingResponse
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof RatingResponse
   */
  point: number;
  /**
   *
   * @type {string}
   * @memberof RatingResponse
   */
  comment: string;
  /**
   *
   * @type {UserResponse}
   * @memberof RatingResponse
   */
  user: UserResponse;
}

export const RatingResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type RatingResponseTypenameEnum =
  (typeof RatingResponseTypenameEnum)[keyof typeof RatingResponseTypenameEnum];

/**
 *
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
  /**
   *
   * @type {string}
   * @memberof RoleResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof RoleResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof RoleResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof RoleResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof RoleResponse
   */
  __typename?: RoleResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof RoleResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof RoleResponse
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof RoleResponse
   */
  type: RoleResponseTypeEnum;
}

export const RoleResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type RoleResponseTypenameEnum =
  (typeof RoleResponseTypenameEnum)[keyof typeof RoleResponseTypenameEnum];
export const RoleResponseTypeEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export type RoleResponseTypeEnum =
  (typeof RoleResponseTypeEnum)[keyof typeof RoleResponseTypeEnum];

/**
 *
 * @export
 * @interface SectionCreate200Response
 */
export interface SectionCreate200Response {
  /**
   *
   * @type {string}
   * @memberof SectionCreate200Response
   */
  message: string;
  /**
   *
   * @type {LessonResponse}
   * @memberof SectionCreate200Response
   */
  data: LessonResponse;
}
/**
 *
 * @export
 * @interface SectionCreate200ResponseAllOf
 */
export interface SectionCreate200ResponseAllOf {
  /**
   *
   * @type {LessonResponse}
   * @memberof SectionCreate200ResponseAllOf
   */
  data?: LessonResponse;
}
/**
 *
 * @export
 * @interface SectionFullResponse
 */
export interface SectionFullResponse {
  /**
   *
   * @type {string}
   * @memberof SectionFullResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof SectionFullResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof SectionFullResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof SectionFullResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof SectionFullResponse
   */
  __typename?: SectionFullResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof SectionFullResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SectionFullResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof SectionFullResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof SectionFullResponse
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof SectionFullResponse
   */
  order: number;
  /**
   *
   * @type {Array<LessonResponse>}
   * @memberof SectionFullResponse
   */
  lessons: Array<LessonResponse>;
}

export const SectionFullResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type SectionFullResponseTypenameEnum =
  (typeof SectionFullResponseTypenameEnum)[keyof typeof SectionFullResponseTypenameEnum];

/**
 *
 * @export
 * @interface StoredFileResponse
 */
export interface StoredFileResponse {
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof StoredFileResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof StoredFileResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  __typename?: StoredFileResponseTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof StoredFileResponse
   */
  path: string;
}

export const StoredFileResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type StoredFileResponseTypenameEnum =
  (typeof StoredFileResponseTypenameEnum)[keyof typeof StoredFileResponseTypenameEnum];

/**
 *
 * @export
 * @interface TeacherResponse
 */
export interface TeacherResponse {
  /**
   *
   * @type {number}
   * @memberof TeacherResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  google_id: string | null;
  /**
   *
   * @type {number}
   * @memberof TeacherResponse
   */
  role_id: number;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  avatar_id: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  phone: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  facebook: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  github: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  twitter: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  job: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  description: string | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TeacherResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TeacherResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TeacherResponse
   */
  __typename?: TeacherResponseTypenameEnum;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof TeacherResponse
   */
  avatar: StoredFileResponse;
  /**
   *
   * @type {RoleResponse}
   * @memberof TeacherResponse
   */
  role: RoleResponse;
  /**
   *
   * @type {WalletResponse}
   * @memberof TeacherResponse
   */
  wallet: WalletResponse;
  /**
   *
   * @type {Array<CourseResponse>}
   * @memberof TeacherResponse
   */
  courses: Array<CourseResponse>;
}

export const TeacherResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TeacherResponseTypenameEnum =
  (typeof TeacherResponseTypenameEnum)[keyof typeof TeacherResponseTypenameEnum];

/**
 *
 * @export
 * @interface TeachingRequestDto
 */
export interface TeachingRequestDto {
  /**
   *
   * @type {number}
   * @memberof TeachingRequestDto
   */
  course_id: number;
}
/**
 *
 * @export
 * @interface TeachingRequestList200Response
 */
export interface TeachingRequestList200Response {
  /**
   *
   * @type {Array<TeachingRequestResponse>}
   * @memberof TeachingRequestList200Response
   */
  data: Array<TeachingRequestResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof TeachingRequestList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof TeachingRequestList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface TeachingRequestList200ResponseAllOf
 */
export interface TeachingRequestList200ResponseAllOf {
  /**
   *
   * @type {Array<TeachingRequestResponse>}
   * @memberof TeachingRequestList200ResponseAllOf
   */
  data?: Array<TeachingRequestResponse>;
}
/**
 *
 * @export
 * @interface TeachingRequestRequest200Response
 */
export interface TeachingRequestRequest200Response {
  /**
   *
   * @type {string}
   * @memberof TeachingRequestRequest200Response
   */
  message: string;
  /**
   *
   * @type {TeachingRequestResponse}
   * @memberof TeachingRequestRequest200Response
   */
  data: TeachingRequestResponse;
}
/**
 *
 * @export
 * @interface TeachingRequestRequest200ResponseAllOf
 */
export interface TeachingRequestRequest200ResponseAllOf {
  /**
   *
   * @type {TeachingRequestResponse}
   * @memberof TeachingRequestRequest200ResponseAllOf
   */
  data?: TeachingRequestResponse;
}
/**
 *
 * @export
 * @interface TeachingRequestResponse
 */
export interface TeachingRequestResponse {
  /**
   *
   * @type {string}
   * @memberof TeachingRequestResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TeachingRequestResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TeachingRequestResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TeachingRequestResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TeachingRequestResponse
   */
  __typename?: TeachingRequestResponseTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof TeachingRequestResponse
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof TeachingRequestResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof TeachingRequestResponse
   */
  course_id: number;
  /**
   *
   * @type {number}
   * @memberof TeachingRequestResponse
   */
  requester_id: number;
  /**
   *
   * @type {CourseResponse}
   * @memberof TeachingRequestResponse
   */
  course: CourseResponse;
  /**
   *
   * @type {UserResponse}
   * @memberof TeachingRequestResponse
   */
  requester: UserResponse;
}

export const TeachingRequestResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TeachingRequestResponseTypenameEnum =
  (typeof TeachingRequestResponseTypenameEnum)[keyof typeof TeachingRequestResponseTypenameEnum];

/**
 *
 * @export
 * @interface TopicFindAll200Response
 */
export interface TopicFindAll200Response {
  /**
   *
   * @type {Array<TopicStatResponse>}
   * @memberof TopicFindAll200Response
   */
  data: Array<TopicStatResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof TopicFindAll200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof TopicFindAll200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface TopicFindAll200ResponseAllOf
 */
export interface TopicFindAll200ResponseAllOf {
  /**
   *
   * @type {Array<TopicStatResponse>}
   * @memberof TopicFindAll200ResponseAllOf
   */
  data?: Array<TopicStatResponse>;
}
/**
 *
 * @export
 * @interface TopicFindOne200Response
 */
export interface TopicFindOne200Response {
  /**
   *
   * @type {string}
   * @memberof TopicFindOne200Response
   */
  message: string;
  /**
   *
   * @type {TopicFullResponse}
   * @memberof TopicFindOne200Response
   */
  data: TopicFullResponse;
}
/**
 *
 * @export
 * @interface TopicFindOne200ResponseAllOf
 */
export interface TopicFindOne200ResponseAllOf {
  /**
   *
   * @type {TopicFullResponse}
   * @memberof TopicFindOne200ResponseAllOf
   */
  data?: TopicFullResponse;
}
/**
 *
 * @export
 * @interface TopicFullResponse
 */
export interface TopicFullResponse {
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicFullResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicFullResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  __typename?: TopicFullResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof TopicFullResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof TopicFullResponse
   */
  cover_id: string;
  /**
   *
   * @type {TopicStatResponseCover}
   * @memberof TopicFullResponse
   */
  cover: TopicStatResponseCover | null;
  /**
   *
   * @type {Array<CategoryResponse>}
   * @memberof TopicFullResponse
   */
  categories: Array<CategoryResponse>;
  /**
   *
   * @type {Array<CourseResponse>}
   * @memberof TopicFullResponse
   */
  courses: Array<CourseResponse>;
}

export const TopicFullResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TopicFullResponseTypenameEnum =
  (typeof TopicFullResponseTypenameEnum)[keyof typeof TopicFullResponseTypenameEnum];

/**
 *
 * @export
 * @interface TopicResponse
 */
export interface TopicResponse {
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  __typename?: TopicResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof TopicResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof TopicResponse
   */
  cover_id: string;
  /**
   *
   * @type {TopicStatResponseCover}
   * @memberof TopicResponse
   */
  cover: TopicStatResponseCover | null;
}

export const TopicResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TopicResponseTypenameEnum =
  (typeof TopicResponseTypenameEnum)[keyof typeof TopicResponseTypenameEnum];

/**
 *
 * @export
 * @interface TopicStatResponse
 */
export interface TopicStatResponse {
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicStatResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicStatResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  __typename?: TopicStatResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof TopicStatResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  slug: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponse
   */
  cover_id: string;
  /**
   *
   * @type {TopicStatResponseCover}
   * @memberof TopicStatResponse
   */
  cover: TopicStatResponseCover | null;
  /**
   *
   * @type {number}
   * @memberof TopicStatResponse
   */
  totalCourses: number;
  /**
   *
   * @type {number}
   * @memberof TopicStatResponse
   */
  totalVideos: number;
}

export const TopicStatResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TopicStatResponseTypenameEnum =
  (typeof TopicStatResponseTypenameEnum)[keyof typeof TopicStatResponseTypenameEnum];

/**
 *
 * @export
 * @interface TopicStatResponseCover
 */
export interface TopicStatResponseCover {
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicStatResponseCover
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof TopicStatResponseCover
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  __typename?: TopicStatResponseCoverTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof TopicStatResponseCover
   */
  path: string;
}

export const TopicStatResponseCoverTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type TopicStatResponseCoverTypenameEnum =
  (typeof TopicStatResponseCoverTypenameEnum)[keyof typeof TopicStatResponseCoverTypenameEnum];

/**
 *
 * @export
 * @interface UpdateSectionDto
 */
export interface UpdateSectionDto {
  /**
   *
   * @type {string}
   * @memberof UpdateSectionDto
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateSectionDto
   */
  description: string;
}
/**
 *
 * @export
 * @interface UserBasicResponse
 */
export interface UserBasicResponse {
  /**
   *
   * @type {number}
   * @memberof UserBasicResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  google_id: string | null;
  /**
   *
   * @type {number}
   * @memberof UserBasicResponse
   */
  role_id: number;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  avatar_id: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  phone: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  facebook: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  github: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  twitter: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  job: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  description: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserBasicResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserBasicResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponse
   */
  __typename?: UserBasicResponseTypenameEnum;
}

export const UserBasicResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type UserBasicResponseTypenameEnum =
  (typeof UserBasicResponseTypenameEnum)[keyof typeof UserBasicResponseTypenameEnum];

/**
 *
 * @export
 * @interface UserBasicResponseCreator
 */
export interface UserBasicResponseCreator {
  /**
   *
   * @type {number}
   * @memberof UserBasicResponseCreator
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  google_id: string | null;
  /**
   *
   * @type {number}
   * @memberof UserBasicResponseCreator
   */
  role_id: number;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  avatar_id: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  phone: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  facebook: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  github: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  twitter: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  job: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  description: string | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserBasicResponseCreator
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserBasicResponseCreator
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof UserBasicResponseCreator
   */
  __typename?: UserBasicResponseCreatorTypenameEnum;
}

export const UserBasicResponseCreatorTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type UserBasicResponseCreatorTypenameEnum =
  (typeof UserBasicResponseCreatorTypenameEnum)[keyof typeof UserBasicResponseCreatorTypenameEnum];

/**
 *
 * @export
 * @interface UserGetTeacher200Response
 */
export interface UserGetTeacher200Response {
  /**
   *
   * @type {Array<TeacherResponse>}
   * @memberof UserGetTeacher200Response
   */
  data: Array<TeacherResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof UserGetTeacher200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof UserGetTeacher200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface UserGetTeacher200ResponseAllOf
 */
export interface UserGetTeacher200ResponseAllOf {
  /**
   *
   * @type {Array<TeacherResponse>}
   * @memberof UserGetTeacher200ResponseAllOf
   */
  data?: Array<TeacherResponse>;
}
/**
 *
 * @export
 * @interface UserList200Response
 */
export interface UserList200Response {
  /**
   *
   * @type {Array<UserResponse>}
   * @memberof UserList200Response
   */
  data: Array<UserResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof UserList200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof UserList200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface UserList200ResponseAllOf
 */
export interface UserList200ResponseAllOf {
  /**
   *
   * @type {Array<UserResponse>}
   * @memberof UserList200ResponseAllOf
   */
  data?: Array<UserResponse>;
}
/**
 *
 * @export
 * @interface UserPublic200Response
 */
export interface UserPublic200Response {
  /**
   *
   * @type {Array<UserPublicResponse>}
   * @memberof UserPublic200Response
   */
  data: Array<UserPublicResponse>;
  /**
   *
   * @type {Pagination}
   * @memberof UserPublic200Response
   */
  pagination: Pagination;
  /**
   *
   * @type {string}
   * @memberof UserPublic200Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface UserPublic200ResponseAllOf
 */
export interface UserPublic200ResponseAllOf {
  /**
   *
   * @type {Array<UserPublicResponse>}
   * @memberof UserPublic200ResponseAllOf
   */
  data?: Array<UserPublicResponse>;
}
/**
 *
 * @export
 * @interface UserPublicResponse
 */
export interface UserPublicResponse {
  /**
   *
   * @type {number}
   * @memberof UserPublicResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserPublicResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserPublicResponse
   */
  email: string;
  /**
   *
   * @type {TopicStatResponseCover}
   * @memberof UserPublicResponse
   */
  avatar: TopicStatResponseCover | null;
  /**
   *
   * @type {string}
   * @memberof UserPublicResponse
   */
  __typename?: UserPublicResponseTypenameEnum;
}

export const UserPublicResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type UserPublicResponseTypenameEnum =
  (typeof UserPublicResponseTypenameEnum)[keyof typeof UserPublicResponseTypenameEnum];

/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   *
   * @type {number}
   * @memberof UserResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  google_id: string | null;
  /**
   *
   * @type {number}
   * @memberof UserResponse
   */
  role_id: number;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  avatar_id: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  phone: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  facebook: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  github: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  twitter: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  job: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  description: string | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof UserResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  __typename?: UserResponseTypenameEnum;
  /**
   *
   * @type {StoredFileResponse}
   * @memberof UserResponse
   */
  avatar: StoredFileResponse;
  /**
   *
   * @type {RoleResponse}
   * @memberof UserResponse
   */
  role: RoleResponse;
  /**
   *
   * @type {WalletResponse}
   * @memberof UserResponse
   */
  wallet: WalletResponse;
}

export const UserResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type UserResponseTypenameEnum =
  (typeof UserResponseTypenameEnum)[keyof typeof UserResponseTypenameEnum];

/**
 *
 * @export
 * @interface UserUpdate200Response
 */
export interface UserUpdate200Response {
  /**
   *
   * @type {string}
   * @memberof UserUpdate200Response
   */
  message: string;
  /**
   *
   * @type {UserResponse}
   * @memberof UserUpdate200Response
   */
  data: UserResponse;
}
/**
 *
 * @export
 * @interface UserUpdate200ResponseAllOf
 */
export interface UserUpdate200ResponseAllOf {
  /**
   *
   * @type {UserResponse}
   * @memberof UserUpdate200ResponseAllOf
   */
  data?: UserResponse;
}
/**
 *
 * @export
 * @interface UserUpdateDto
 */
export interface UserUpdateDto {
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  facebook?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  github?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  twitter?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  job?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateDto
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ValidationExceptionErrorResponse
 */
export interface ValidationExceptionErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationExceptionErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationExceptionErrorResponse
   */
  message: string;
}
/**
 *
 * @export
 * @interface ValidationExceptionResponse
 */
export interface ValidationExceptionResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationExceptionResponse
   */
  name: string;
  /**
   *
   * @type {Array<ValidationExceptionErrorResponse>}
   * @memberof ValidationExceptionResponse
   */
  errors: Array<ValidationExceptionErrorResponse>;
}
/**
 *
 * @export
 * @interface WalletResponse
 */
export interface WalletResponse {
  /**
   *
   * @type {string}
   * @memberof WalletResponse
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof WalletResponse
   */
  updated_at: string;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof WalletResponse
   */
  creator: UserBasicResponseCreator | null;
  /**
   *
   * @type {UserBasicResponseCreator}
   * @memberof WalletResponse
   */
  updater: UserBasicResponseCreator | null;
  /**
   *
   * @type {string}
   * @memberof WalletResponse
   */
  __typename?: WalletResponseTypenameEnum;
  /**
   *
   * @type {number}
   * @memberof WalletResponse
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof WalletResponse
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof WalletResponse
   */
  balance: number;
}

export const WalletResponseTypenameEnum = {
  All: 'all',
  Users: 'users',
  Roles: 'roles',
  StoredFiles: 'stored_files',
  Categories: 'categories',
  Topics: 'topics',
  Courses: 'courses',
  Sections: 'sections',
  Lessons: 'lessons',
  Discussions: 'discussions',
  Assignments: 'assignments',
  TeachingRequests: 'teaching_requests',
  LearningRequests: 'learning_requests',
  CourseTeachers: 'course_teachers',
  CourseStudents: 'course_students',
  NotificationSubscriptions: 'notification_subscriptions',
  CoursePrices: 'course_prices',
  Wallets: 'wallets',
  RatingCourses: 'rating_courses',
} as const;

export type WalletResponseTypenameEnum =
  (typeof WalletResponseTypenameEnum)[keyof typeof WalletResponseTypenameEnum];

/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getData(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getData(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AppApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getData(options?: any): AxiosPromise<void> {
      return localVarFp
        .getData(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApi
   */
  public getData(options?: AxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .getData(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AssignmentsApi - axios parameter creator
 * @export
 */
export const AssignmentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_delete', 'id', id);
      const localVarPath = `/api/discussions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete_1: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_delete_1', 'id', id);
      const localVarPath = `/api/assignments/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CreateAssignmentDto} createAssignmentDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      createAssignmentDto: CreateAssignmentDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAssignmentDto' is not null or undefined
      assertParamExists('create', 'createAssignmentDto', createAssignmentDto);
      const localVarPath = `/api/assignments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAssignmentDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      lessonId: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lessonId' is not null or undefined
      assertParamExists('list', 'lessonId', lessonId);
      const localVarPath = `/api/assignments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lessonId !== undefined) {
        localVarQueryParameter['lesson_id'] = lessonId;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssignmentsApi - functional programming interface
 * @export
 */
export const AssignmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AssignmentsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DiscussionDelete200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete_1(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DiscussionDelete200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete_1(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {CreateAssignmentDto} createAssignmentDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      createAssignmentDto: CreateAssignmentDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AssignmentCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        createAssignmentDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      lessonId: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AssignmentList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        lessonId,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AssignmentsApi - factory interface
 * @export
 */
export const AssignmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AssignmentsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(
      id: string,
      options?: any
    ): AxiosPromise<DiscussionDelete200Response> {
      return localVarFp
        ._delete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete_1(
      id: string,
      options?: any
    ): AxiosPromise<DiscussionDelete200Response> {
      return localVarFp
        ._delete_1(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CreateAssignmentDto} createAssignmentDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      createAssignmentDto: CreateAssignmentDto,
      options?: any
    ): AxiosPromise<AssignmentCreate200Response> {
      return localVarFp
        .create(createAssignmentDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      lessonId: number,
      page?: number,
      options?: any
    ): AxiosPromise<AssignmentList200Response> {
      return localVarFp
        .list(lessonId, page, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for _delete operation in AssignmentsApi.
 * @export
 * @interface AssignmentsApiDeleteRequest
 */
export interface AssignmentsApiDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof AssignmentsApiDelete
   */
  readonly id: string;
}

/**
 * Request parameters for _delete_1 operation in AssignmentsApi.
 * @export
 * @interface AssignmentsApiDelete0Request
 */
export interface AssignmentsApiDelete0Request {
  /**
   *
   * @type {string}
   * @memberof AssignmentsApiDelete0
   */
  readonly id: string;
}

/**
 * Request parameters for create operation in AssignmentsApi.
 * @export
 * @interface AssignmentsApiCreateRequest
 */
export interface AssignmentsApiCreateRequest {
  /**
   *
   * @type {CreateAssignmentDto}
   * @memberof AssignmentsApiCreate
   */
  readonly createAssignmentDto: CreateAssignmentDto;
}

/**
 * Request parameters for list operation in AssignmentsApi.
 * @export
 * @interface AssignmentsApiListRequest
 */
export interface AssignmentsApiListRequest {
  /**
   *
   * @type {number}
   * @memberof AssignmentsApiList
   */
  readonly lessonId: number;

  /**
   *
   * @type {number}
   * @memberof AssignmentsApiList
   */
  readonly page?: number;
}

/**
 * AssignmentsApi - object-oriented interface
 * @export
 * @class AssignmentsApi
 * @extends {BaseAPI}
 */
export class AssignmentsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {AssignmentsApiDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssignmentsApi
   */
  public _delete(
    requestParameters: AssignmentsApiDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return AssignmentsApiFp(this.configuration)
      ._delete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AssignmentsApiDelete0Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssignmentsApi
   */
  public _delete_1(
    requestParameters: AssignmentsApiDelete0Request,
    options?: AxiosRequestConfig
  ) {
    return AssignmentsApiFp(this.configuration)
      ._delete_1(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AssignmentsApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssignmentsApi
   */
  public create(
    requestParameters: AssignmentsApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return AssignmentsApiFp(this.configuration)
      .create(requestParameters.createAssignmentDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AssignmentsApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssignmentsApi
   */
  public list(
    requestParameters: AssignmentsApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return AssignmentsApiFp(this.configuration)
      .list(requestParameters.lessonId, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserUpdate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me(options?: any): AxiosPromise<UserUpdate200Response> {
      return localVarFp.me(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public me(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .me(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthGoogleApi - axios parameter creator
 * @export
 */
export const AuthGoogleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {GoogleLoginDto} googleLoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      googleLoginDto: GoogleLoginDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'googleLoginDto' is not null or undefined
      assertParamExists('login', 'googleLoginDto', googleLoginDto);
      const localVarPath = `/api/auth/google`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        googleLoginDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthGoogleApi - functional programming interface
 * @export
 */
export const AuthGoogleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthGoogleApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {GoogleLoginDto} googleLoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      googleLoginDto: GoogleLoginDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GoogleLogin200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        googleLoginDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthGoogleApi - factory interface
 * @export
 */
export const AuthGoogleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthGoogleApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {GoogleLoginDto} googleLoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      googleLoginDto: GoogleLoginDto,
      options?: any
    ): AxiosPromise<GoogleLogin200Response> {
      return localVarFp
        .login(googleLoginDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for login operation in AuthGoogleApi.
 * @export
 * @interface AuthGoogleApiLoginRequest
 */
export interface AuthGoogleApiLoginRequest {
  /**
   *
   * @type {GoogleLoginDto}
   * @memberof AuthGoogleApiLogin
   */
  readonly googleLoginDto: GoogleLoginDto;
}

/**
 * AuthGoogleApi - object-oriented interface
 * @export
 * @class AuthGoogleApi
 * @extends {BaseAPI}
 */
export class AuthGoogleApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {AuthGoogleApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthGoogleApi
   */
  public login(
    requestParameters: AuthGoogleApiLoginRequest,
    options?: AxiosRequestConfig
  ) {
    return AuthGoogleApiFp(this.configuration)
      .login(requestParameters.googleLoginDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CategoriesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CategoryList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CategoriesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<CategoryList200Response> {
      return localVarFp
        .list(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public list(options?: AxiosRequestConfig) {
    return CategoriesApiFp(this.configuration)
      .list(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_delete', 'id', id);
      const localVarPath = `/api/courses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} name
     * @param {string} description
     * @param {File} cover
     * @param {number} mode
     * @param {number} [price]
     * @param {Array<number>} [topicsIds]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      name: string,
      description: string,
      cover: File,
      mode: number,
      price?: number,
      topicsIds?: Array<number>,
      discount?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('create', 'name', name);
      // verify required parameter 'description' is not null or undefined
      assertParamExists('create', 'description', description);
      // verify required parameter 'cover' is not null or undefined
      assertParamExists('create', 'cover', cover);
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('create', 'mode', mode);
      const localVarPath = `/api/courses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (name !== undefined) {
        localVarFormParams.append('name', name as any);
      }

      if (description !== undefined) {
        localVarFormParams.append('description', description as any);
      }

      if (cover !== undefined) {
        localVarFormParams.append('cover', cover as any);
      }

      if (mode !== undefined) {
        localVarFormParams.append('mode', mode as any);
      }

      if (price !== undefined) {
        localVarFormParams.append('price', price as any);
      }
      if (topicsIds) {
        localVarFormParams.append(
          'topics_ids[]',
          topicsIds.join(COLLECTION_FORMATS.csv)
        );
      }

      if (discount !== undefined) {
        localVarFormParams.append('discount', discount as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCourseLearnings: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/courses/learnings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne: async (
      slug: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slug' is not null or undefined
      assertParamExists('findOne', 'slug', slug);
      const localVarPath = `/api/courses/{slug}`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      status: number,
      page: number,
      limit: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'status' is not null or undefined
      assertParamExists('list', 'status', status);
      // verify required parameter 'page' is not null or undefined
      assertParamExists('list', 'page', page);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('list', 'limit', limit);
      const localVarPath = `/api/courses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCoursesMange: async (
      status: number,
      page: number,
      limit: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'status' is not null or undefined
      assertParamExists('listCoursesMange', 'status', status);
      // verify required parameter 'page' is not null or undefined
      assertParamExists('listCoursesMange', 'page', page);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('listCoursesMange', 'limit', limit);
      const localVarPath = `/api/courses/manage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/courses/stats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} name
     * @param {string} description
     * @param {number} mode
     * @param {File} [cover]
     * @param {Array<number>} [topicsIds]
     * @param {number} [price]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      id: number,
      name: string,
      description: string,
      mode: number,
      cover?: File,
      topicsIds?: Array<number>,
      price?: number,
      discount?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('update', 'id', id);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('update', 'name', name);
      // verify required parameter 'description' is not null or undefined
      assertParamExists('update', 'description', description);
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('update', 'mode', mode);
      const localVarPath = `/api/courses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (name !== undefined) {
        localVarFormParams.append('name', name as any);
      }

      if (description !== undefined) {
        localVarFormParams.append('description', description as any);
      }

      if (cover !== undefined) {
        localVarFormParams.append('cover', cover as any);
      }
      if (topicsIds) {
        localVarFormParams.append(
          'topics_ids[]',
          topicsIds.join(COLLECTION_FORMATS.csv)
        );
      }

      if (mode !== undefined) {
        localVarFormParams.append('mode', mode as any);
      }

      if (price !== undefined) {
        localVarFormParams.append('price', price as any);
      }

      if (discount !== undefined) {
        localVarFormParams.append('discount', discount as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseDelete200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} name
     * @param {string} description
     * @param {File} cover
     * @param {number} mode
     * @param {number} [price]
     * @param {Array<number>} [topicsIds]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      name: string,
      description: string,
      cover: File,
      mode: number,
      price?: number,
      topicsIds?: Array<number>,
      discount?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        name,
        description,
        cover,
        mode,
        price,
        topicsIds,
        discount,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findCourseLearnings(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseFindCourseLearnings200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.findCourseLearnings(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findOne(
      slug: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseFindOne200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(
        slug,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      status: number,
      page: number,
      limit: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        status,
        page,
        limit,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCoursesMange(
      status: number,
      page: number,
      limit: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseList200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCoursesMange(
          status,
          page,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stats(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseStats200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stats(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} name
     * @param {string} description
     * @param {number} mode
     * @param {File} [cover]
     * @param {Array<number>} [topicsIds]
     * @param {number} [price]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      id: number,
      name: string,
      description: string,
      mode: number,
      cover?: File,
      topicsIds?: Array<number>,
      price?: number,
      discount?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        id,
        name,
        description,
        mode,
        cover,
        topicsIds,
        price,
        discount,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CoursesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: any): AxiosPromise<CourseDelete200Response> {
      return localVarFp
        ._delete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} name
     * @param {string} description
     * @param {File} cover
     * @param {number} mode
     * @param {number} [price]
     * @param {Array<number>} [topicsIds]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      name: string,
      description: string,
      cover: File,
      mode: number,
      price?: number,
      topicsIds?: Array<number>,
      discount?: number,
      options?: any
    ): AxiosPromise<CourseCreate200Response> {
      return localVarFp
        .create(
          name,
          description,
          cover,
          mode,
          price,
          topicsIds,
          discount,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCourseLearnings(
      options?: any
    ): AxiosPromise<CourseFindCourseLearnings200Response> {
      return localVarFp
        .findCourseLearnings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne(
      slug: string,
      options?: any
    ): AxiosPromise<CourseFindOne200Response> {
      return localVarFp
        .findOne(slug, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      status: number,
      page: number,
      limit: number,
      options?: any
    ): AxiosPromise<CourseList200Response> {
      return localVarFp
        .list(status, page, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCoursesMange(
      status: number,
      page: number,
      limit: number,
      options?: any
    ): AxiosPromise<CourseList200Response> {
      return localVarFp
        .listCoursesMange(status, page, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stats(options?: any): AxiosPromise<CourseStats200Response> {
      return localVarFp
        .stats(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} name
     * @param {string} description
     * @param {number} mode
     * @param {File} [cover]
     * @param {Array<number>} [topicsIds]
     * @param {number} [price]
     * @param {number} [discount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      id: number,
      name: string,
      description: string,
      mode: number,
      cover?: File,
      topicsIds?: Array<number>,
      price?: number,
      discount?: number,
      options?: any
    ): AxiosPromise<CourseCreate200Response> {
      return localVarFp
        .update(
          id,
          name,
          description,
          mode,
          cover,
          topicsIds,
          price,
          discount,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for _delete operation in CoursesApi.
 * @export
 * @interface CoursesApiDeleteRequest
 */
export interface CoursesApiDeleteRequest {
  /**
   *
   * @type {number}
   * @memberof CoursesApiDelete
   */
  readonly id: number;
}

/**
 * Request parameters for create operation in CoursesApi.
 * @export
 * @interface CoursesApiCreateRequest
 */
export interface CoursesApiCreateRequest {
  /**
   *
   * @type {string}
   * @memberof CoursesApiCreate
   */
  readonly name: string;

  /**
   *
   * @type {string}
   * @memberof CoursesApiCreate
   */
  readonly description: string;

  /**
   *
   * @type {File}
   * @memberof CoursesApiCreate
   */
  readonly cover: File;

  /**
   *
   * @type {number}
   * @memberof CoursesApiCreate
   */
  readonly mode: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiCreate
   */
  readonly price?: number;

  /**
   *
   * @type {Array<number>}
   * @memberof CoursesApiCreate
   */
  readonly topicsIds?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof CoursesApiCreate
   */
  readonly discount?: number;
}

/**
 * Request parameters for findOne operation in CoursesApi.
 * @export
 * @interface CoursesApiFindOneRequest
 */
export interface CoursesApiFindOneRequest {
  /**
   *
   * @type {string}
   * @memberof CoursesApiFindOne
   */
  readonly slug: string;
}

/**
 * Request parameters for list operation in CoursesApi.
 * @export
 * @interface CoursesApiListRequest
 */
export interface CoursesApiListRequest {
  /**
   *
   * @type {number}
   * @memberof CoursesApiList
   */
  readonly status: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiList
   */
  readonly page: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiList
   */
  readonly limit: number;
}

/**
 * Request parameters for listCoursesMange operation in CoursesApi.
 * @export
 * @interface CoursesApiListCoursesMangeRequest
 */
export interface CoursesApiListCoursesMangeRequest {
  /**
   *
   * @type {number}
   * @memberof CoursesApiListCoursesMange
   */
  readonly status: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiListCoursesMange
   */
  readonly page: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiListCoursesMange
   */
  readonly limit: number;
}

/**
 * Request parameters for update operation in CoursesApi.
 * @export
 * @interface CoursesApiUpdateRequest
 */
export interface CoursesApiUpdateRequest {
  /**
   *
   * @type {number}
   * @memberof CoursesApiUpdate
   */
  readonly id: number;

  /**
   *
   * @type {string}
   * @memberof CoursesApiUpdate
   */
  readonly name: string;

  /**
   *
   * @type {string}
   * @memberof CoursesApiUpdate
   */
  readonly description: string;

  /**
   *
   * @type {number}
   * @memberof CoursesApiUpdate
   */
  readonly mode: number;

  /**
   *
   * @type {File}
   * @memberof CoursesApiUpdate
   */
  readonly cover?: File;

  /**
   *
   * @type {Array<number>}
   * @memberof CoursesApiUpdate
   */
  readonly topicsIds?: Array<number>;

  /**
   *
   * @type {number}
   * @memberof CoursesApiUpdate
   */
  readonly price?: number;

  /**
   *
   * @type {number}
   * @memberof CoursesApiUpdate
   */
  readonly discount?: number;
}

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {CoursesApiDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public _delete(
    requestParameters: CoursesApiDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      ._delete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CoursesApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public create(
    requestParameters: CoursesApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      .create(
        requestParameters.name,
        requestParameters.description,
        requestParameters.cover,
        requestParameters.mode,
        requestParameters.price,
        requestParameters.topicsIds,
        requestParameters.discount,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public findCourseLearnings(options?: AxiosRequestConfig) {
    return CoursesApiFp(this.configuration)
      .findCourseLearnings(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CoursesApiFindOneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public findOne(
    requestParameters: CoursesApiFindOneRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      .findOne(requestParameters.slug, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CoursesApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public list(
    requestParameters: CoursesApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      .list(
        requestParameters.status,
        requestParameters.page,
        requestParameters.limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CoursesApiListCoursesMangeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public listCoursesMange(
    requestParameters: CoursesApiListCoursesMangeRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      .listCoursesMange(
        requestParameters.status,
        requestParameters.page,
        requestParameters.limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public stats(options?: AxiosRequestConfig) {
    return CoursesApiFp(this.configuration)
      .stats(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CoursesApiUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoursesApi
   */
  public update(
    requestParameters: CoursesApiUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return CoursesApiFp(this.configuration)
      .update(
        requestParameters.id,
        requestParameters.name,
        requestParameters.description,
        requestParameters.mode,
        requestParameters.cover,
        requestParameters.topicsIds,
        requestParameters.price,
        requestParameters.discount,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DiscussionsApi - axios parameter creator
 * @export
 */
export const DiscussionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {CreateDiscussionDto} createDiscussionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      createDiscussionDto: CreateDiscussionDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDiscussionDto' is not null or undefined
      assertParamExists('create', 'createDiscussionDto', createDiscussionDto);
      const localVarPath = `/api/discussions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDiscussionDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      lessonId: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lessonId' is not null or undefined
      assertParamExists('list', 'lessonId', lessonId);
      const localVarPath = `/api/discussions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lessonId !== undefined) {
        localVarQueryParameter['lesson_id'] = lessonId;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DiscussionsApi - functional programming interface
 * @export
 */
export const DiscussionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DiscussionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {CreateDiscussionDto} createDiscussionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      createDiscussionDto: CreateDiscussionDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DiscussionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        createDiscussionDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      lessonId: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DiscussionList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        lessonId,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DiscussionsApi - factory interface
 * @export
 */
export const DiscussionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DiscussionsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {CreateDiscussionDto} createDiscussionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      createDiscussionDto: CreateDiscussionDto,
      options?: any
    ): AxiosPromise<DiscussionCreate200Response> {
      return localVarFp
        .create(createDiscussionDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} lessonId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      lessonId: number,
      page?: number,
      options?: any
    ): AxiosPromise<DiscussionList200Response> {
      return localVarFp
        .list(lessonId, page, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for create operation in DiscussionsApi.
 * @export
 * @interface DiscussionsApiCreateRequest
 */
export interface DiscussionsApiCreateRequest {
  /**
   *
   * @type {CreateDiscussionDto}
   * @memberof DiscussionsApiCreate
   */
  readonly createDiscussionDto: CreateDiscussionDto;
}

/**
 * Request parameters for list operation in DiscussionsApi.
 * @export
 * @interface DiscussionsApiListRequest
 */
export interface DiscussionsApiListRequest {
  /**
   *
   * @type {number}
   * @memberof DiscussionsApiList
   */
  readonly lessonId: number;

  /**
   *
   * @type {number}
   * @memberof DiscussionsApiList
   */
  readonly page?: number;
}

/**
 * DiscussionsApi - object-oriented interface
 * @export
 * @class DiscussionsApi
 * @extends {BaseAPI}
 */
export class DiscussionsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {DiscussionsApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscussionsApi
   */
  public create(
    requestParameters: DiscussionsApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return DiscussionsApiFp(this.configuration)
      .create(requestParameters.createDiscussionDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {DiscussionsApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscussionsApi
   */
  public list(
    requestParameters: DiscussionsApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return DiscussionsApiFp(this.configuration)
      .list(requestParameters.lessonId, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LeariningRequestsApi - axios parameter creator
 * @export
 */
export const LeariningRequestsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accept: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('accept', 'id', id);
      const localVarPath = `/api/learning-requests/accept/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('findOne', 'id', id);
      const localVarPath = `/api/learning-requests/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      status: number,
      page: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'status' is not null or undefined
      assertParamExists('list', 'status', status);
      // verify required parameter 'page' is not null or undefined
      assertParamExists('list', 'page', page);
      const localVarPath = `/api/learning-requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reject: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('reject', 'id', id);
      const localVarPath = `/api/learning-requests/reject/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {LearningRequestDto} learningRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    request: async (
      learningRequestDto: LearningRequestDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'learningRequestDto' is not null or undefined
      assertParamExists('request', 'learningRequestDto', learningRequestDto);
      const localVarPath = `/api/learning-requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        learningRequestDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LeariningRequestsApi - functional programming interface
 * @export
 */
export const LeariningRequestsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LeariningRequestsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accept(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LearningRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accept(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findOne(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LearningRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      status: number,
      page: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LearningRequestList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        status,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reject(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LearningRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reject(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {LearningRequestDto} learningRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async request(
      learningRequestDto: LearningRequestDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LearningRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.request(
        learningRequestDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LeariningRequestsApi - factory interface
 * @export
 */
export const LeariningRequestsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LeariningRequestsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accept(
      id: string,
      options?: any
    ): AxiosPromise<LearningRequestRequest200Response> {
      return localVarFp
        .accept(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne(
      id: string,
      options?: any
    ): AxiosPromise<LearningRequestRequest200Response> {
      return localVarFp
        .findOne(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      status: number,
      page: number,
      options?: any
    ): AxiosPromise<LearningRequestList200Response> {
      return localVarFp
        .list(status, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reject(
      id: string,
      options?: any
    ): AxiosPromise<LearningRequestRequest200Response> {
      return localVarFp
        .reject(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {LearningRequestDto} learningRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    request(
      learningRequestDto: LearningRequestDto,
      options?: any
    ): AxiosPromise<LearningRequestRequest200Response> {
      return localVarFp
        .request(learningRequestDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for accept operation in LeariningRequestsApi.
 * @export
 * @interface LeariningRequestsApiAcceptRequest
 */
export interface LeariningRequestsApiAcceptRequest {
  /**
   *
   * @type {string}
   * @memberof LeariningRequestsApiAccept
   */
  readonly id: string;
}

/**
 * Request parameters for findOne operation in LeariningRequestsApi.
 * @export
 * @interface LeariningRequestsApiFindOneRequest
 */
export interface LeariningRequestsApiFindOneRequest {
  /**
   *
   * @type {string}
   * @memberof LeariningRequestsApiFindOne
   */
  readonly id: string;
}

/**
 * Request parameters for list operation in LeariningRequestsApi.
 * @export
 * @interface LeariningRequestsApiListRequest
 */
export interface LeariningRequestsApiListRequest {
  /**
   *
   * @type {number}
   * @memberof LeariningRequestsApiList
   */
  readonly status: number;

  /**
   *
   * @type {number}
   * @memberof LeariningRequestsApiList
   */
  readonly page: number;
}

/**
 * Request parameters for reject operation in LeariningRequestsApi.
 * @export
 * @interface LeariningRequestsApiRejectRequest
 */
export interface LeariningRequestsApiRejectRequest {
  /**
   *
   * @type {string}
   * @memberof LeariningRequestsApiReject
   */
  readonly id: string;
}

/**
 * Request parameters for request operation in LeariningRequestsApi.
 * @export
 * @interface LeariningRequestsApiRequestRequest
 */
export interface LeariningRequestsApiRequestRequest {
  /**
   *
   * @type {LearningRequestDto}
   * @memberof LeariningRequestsApiRequest
   */
  readonly learningRequestDto: LearningRequestDto;
}

/**
 * LeariningRequestsApi - object-oriented interface
 * @export
 * @class LeariningRequestsApi
 * @extends {BaseAPI}
 */
export class LeariningRequestsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {LeariningRequestsApiAcceptRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeariningRequestsApi
   */
  public accept(
    requestParameters: LeariningRequestsApiAcceptRequest,
    options?: AxiosRequestConfig
  ) {
    return LeariningRequestsApiFp(this.configuration)
      .accept(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LeariningRequestsApiFindOneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeariningRequestsApi
   */
  public findOne(
    requestParameters: LeariningRequestsApiFindOneRequest,
    options?: AxiosRequestConfig
  ) {
    return LeariningRequestsApiFp(this.configuration)
      .findOne(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LeariningRequestsApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeariningRequestsApi
   */
  public list(
    requestParameters: LeariningRequestsApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return LeariningRequestsApiFp(this.configuration)
      .list(requestParameters.status, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LeariningRequestsApiRejectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeariningRequestsApi
   */
  public reject(
    requestParameters: LeariningRequestsApiRejectRequest,
    options?: AxiosRequestConfig
  ) {
    return LeariningRequestsApiFp(this.configuration)
      .reject(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LeariningRequestsApiRequestRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeariningRequestsApi
   */
  public request(
    requestParameters: LeariningRequestsApiRequestRequest,
    options?: AxiosRequestConfig
  ) {
    return LeariningRequestsApiFp(this.configuration)
      .request(requestParameters.learningRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LessonsApi - axios parameter creator
 * @export
 */
export const LessonsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_delete', 'id', id);
      const localVarPath = `/api/lesson/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} sectionId
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      sectionId: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sectionId' is not null or undefined
      assertParamExists('create', 'sectionId', sectionId);
      // verify required parameter 'title' is not null or undefined
      assertParamExists('create', 'title', title);
      // verify required parameter 'description' is not null or undefined
      assertParamExists('create', 'description', description);
      // verify required parameter 'type' is not null or undefined
      assertParamExists('create', 'type', type);
      // verify required parameter 'time' is not null or undefined
      assertParamExists('create', 'time', time);
      const localVarPath = `/api/lesson`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (sectionId !== undefined) {
        localVarFormParams.append('section_id', sectionId as any);
      }

      if (title !== undefined) {
        localVarFormParams.append('title', title as any);
      }

      if (description !== undefined) {
        localVarFormParams.append('description', description as any);
      }

      if (link !== undefined) {
        localVarFormParams.append('link', link as any);
      }

      if (video !== undefined) {
        localVarFormParams.append('video', video as any);
      }

      if (type !== undefined) {
        localVarFormParams.append('type', type as any);
      }

      if (time !== undefined) {
        localVarFormParams.append('time', time as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      id: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('update', 'id', id);
      // verify required parameter 'title' is not null or undefined
      assertParamExists('update', 'title', title);
      // verify required parameter 'description' is not null or undefined
      assertParamExists('update', 'description', description);
      // verify required parameter 'type' is not null or undefined
      assertParamExists('update', 'type', type);
      // verify required parameter 'time' is not null or undefined
      assertParamExists('update', 'time', time);
      const localVarPath = `/api/lesson/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (title !== undefined) {
        localVarFormParams.append('title', title as any);
      }

      if (description !== undefined) {
        localVarFormParams.append('description', description as any);
      }

      if (link !== undefined) {
        localVarFormParams.append('link', link as any);
      }

      if (video !== undefined) {
        localVarFormParams.append('video', video as any);
      }

      if (type !== undefined) {
        localVarFormParams.append('type', type as any);
      }

      if (time !== undefined) {
        localVarFormParams.append('time', time as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LessonsApi - functional programming interface
 * @export
 */
export const LessonsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LessonsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseDelete200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} sectionId
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      sectionId: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SectionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        sectionId,
        title,
        description,
        type,
        time,
        link,
        video,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      id: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SectionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        id,
        title,
        description,
        type,
        time,
        link,
        video,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LessonsApi - factory interface
 * @export
 */
export const LessonsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LessonsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: any): AxiosPromise<CourseDelete200Response> {
      return localVarFp
        ._delete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} sectionId
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      sectionId: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options?: any
    ): AxiosPromise<SectionCreate200Response> {
      return localVarFp
        .create(sectionId, title, description, type, time, link, video, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {string} title
     * @param {string} description
     * @param {number} type
     * @param {number} time
     * @param {string} [link]
     * @param {File} [video]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      id: number,
      title: string,
      description: string,
      type: number,
      time: number,
      link?: string,
      video?: File,
      options?: any
    ): AxiosPromise<SectionCreate200Response> {
      return localVarFp
        .update(id, title, description, type, time, link, video, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for _delete operation in LessonsApi.
 * @export
 * @interface LessonsApiDeleteRequest
 */
export interface LessonsApiDeleteRequest {
  /**
   *
   * @type {number}
   * @memberof LessonsApiDelete
   */
  readonly id: number;
}

/**
 * Request parameters for create operation in LessonsApi.
 * @export
 * @interface LessonsApiCreateRequest
 */
export interface LessonsApiCreateRequest {
  /**
   *
   * @type {number}
   * @memberof LessonsApiCreate
   */
  readonly sectionId: number;

  /**
   *
   * @type {string}
   * @memberof LessonsApiCreate
   */
  readonly title: string;

  /**
   *
   * @type {string}
   * @memberof LessonsApiCreate
   */
  readonly description: string;

  /**
   *
   * @type {number}
   * @memberof LessonsApiCreate
   */
  readonly type: number;

  /**
   *
   * @type {number}
   * @memberof LessonsApiCreate
   */
  readonly time: number;

  /**
   *
   * @type {string}
   * @memberof LessonsApiCreate
   */
  readonly link?: string;

  /**
   *
   * @type {File}
   * @memberof LessonsApiCreate
   */
  readonly video?: File;
}

/**
 * Request parameters for update operation in LessonsApi.
 * @export
 * @interface LessonsApiUpdateRequest
 */
export interface LessonsApiUpdateRequest {
  /**
   *
   * @type {number}
   * @memberof LessonsApiUpdate
   */
  readonly id: number;

  /**
   *
   * @type {string}
   * @memberof LessonsApiUpdate
   */
  readonly title: string;

  /**
   *
   * @type {string}
   * @memberof LessonsApiUpdate
   */
  readonly description: string;

  /**
   *
   * @type {number}
   * @memberof LessonsApiUpdate
   */
  readonly type: number;

  /**
   *
   * @type {number}
   * @memberof LessonsApiUpdate
   */
  readonly time: number;

  /**
   *
   * @type {string}
   * @memberof LessonsApiUpdate
   */
  readonly link?: string;

  /**
   *
   * @type {File}
   * @memberof LessonsApiUpdate
   */
  readonly video?: File;
}

/**
 * LessonsApi - object-oriented interface
 * @export
 * @class LessonsApi
 * @extends {BaseAPI}
 */
export class LessonsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {LessonsApiDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonsApi
   */
  public _delete(
    requestParameters: LessonsApiDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return LessonsApiFp(this.configuration)
      ._delete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LessonsApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonsApi
   */
  public create(
    requestParameters: LessonsApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return LessonsApiFp(this.configuration)
      .create(
        requestParameters.sectionId,
        requestParameters.title,
        requestParameters.description,
        requestParameters.type,
        requestParameters.time,
        requestParameters.link,
        requestParameters.video,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {LessonsApiUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonsApi
   */
  public update(
    requestParameters: LessonsApiUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return LessonsApiFp(this.configuration)
      .update(
        requestParameters.id,
        requestParameters.title,
        requestParameters.description,
        requestParameters.type,
        requestParameters.time,
        requestParameters.link,
        requestParameters.video,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * NotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export const NotificationSubscriptionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {NotificationSubscriptionCreateDto} notificationSubscriptionCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      notificationSubscriptionCreateDto: NotificationSubscriptionCreateDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notificationSubscriptionCreateDto' is not null or undefined
      assertParamExists(
        'create',
        'notificationSubscriptionCreateDto',
        notificationSubscriptionCreateDto
      );
      const localVarPath = `/api/notification-subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        notificationSubscriptionCreateDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NotificationSubscriptionsApi - functional programming interface
 * @export
 */
export const NotificationSubscriptionsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    NotificationSubscriptionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {NotificationSubscriptionCreateDto} notificationSubscriptionCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      notificationSubscriptionCreateDto: NotificationSubscriptionCreateDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationSubscriptionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        notificationSubscriptionCreateDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * NotificationSubscriptionsApi - factory interface
 * @export
 */
export const NotificationSubscriptionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = NotificationSubscriptionsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {NotificationSubscriptionCreateDto} notificationSubscriptionCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      notificationSubscriptionCreateDto: NotificationSubscriptionCreateDto,
      options?: any
    ): AxiosPromise<NotificationSubscriptionCreate200Response> {
      return localVarFp
        .create(notificationSubscriptionCreateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for create operation in NotificationSubscriptionsApi.
 * @export
 * @interface NotificationSubscriptionsApiCreateRequest
 */
export interface NotificationSubscriptionsApiCreateRequest {
  /**
   *
   * @type {NotificationSubscriptionCreateDto}
   * @memberof NotificationSubscriptionsApiCreate
   */
  readonly notificationSubscriptionCreateDto: NotificationSubscriptionCreateDto;
}

/**
 * NotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class NotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export class NotificationSubscriptionsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {NotificationSubscriptionsApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationSubscriptionsApi
   */
  public create(
    requestParameters: NotificationSubscriptionsApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return NotificationSubscriptionsApiFp(this.configuration)
      .create(requestParameters.notificationSubscriptionCreateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {0 | 1} read
     * @param {number} limit
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      read: 0 | 1,
      limit: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'read' is not null or undefined
      assertParamExists('list', 'read', read);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('list', 'limit', limit);
      const localVarPath = `/api/notifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (read !== undefined) {
        localVarQueryParameter['read'] = read;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAllNotification: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/notifications/mark-as-read`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readNotification: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readNotification', 'id', id);
      const localVarPath = `/api/notifications/{id}/mark-as-read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    NotificationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {0 | 1} read
     * @param {number} limit
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      read: 0 | 1,
      limit: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationsList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        read,
        limit,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readAllNotification(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationsReadAllNotification200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readAllNotification(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readNotification(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationsReadNotification200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readNotification(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = NotificationsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {0 | 1} read
     * @param {number} limit
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      read: 0 | 1,
      limit: number,
      page?: number,
      options?: any
    ): AxiosPromise<NotificationsList200Response> {
      return localVarFp
        .list(read, limit, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAllNotification(
      options?: any
    ): AxiosPromise<NotificationsReadAllNotification200Response> {
      return localVarFp
        .readAllNotification(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readNotification(
      id: number,
      options?: any
    ): AxiosPromise<NotificationsReadNotification200Response> {
      return localVarFp
        .readNotification(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for list operation in NotificationsApi.
 * @export
 * @interface NotificationsApiListRequest
 */
export interface NotificationsApiListRequest {
  /**
   *
   * @type {0 | 1}
   * @memberof NotificationsApiList
   */
  readonly read: 0 | 1;

  /**
   *
   * @type {number}
   * @memberof NotificationsApiList
   */
  readonly limit: number;

  /**
   *
   * @type {number}
   * @memberof NotificationsApiList
   */
  readonly page?: number;
}

/**
 * Request parameters for readNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiReadNotificationRequest
 */
export interface NotificationsApiReadNotificationRequest {
  /**
   *
   * @type {number}
   * @memberof NotificationsApiReadNotification
   */
  readonly id: number;
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {NotificationsApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public list(
    requestParameters: NotificationsApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return NotificationsApiFp(this.configuration)
      .list(
        requestParameters.read,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public readAllNotification(options?: AxiosRequestConfig) {
    return NotificationsApiFp(this.configuration)
      .readAllNotification(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {NotificationsApiReadNotificationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public readNotification(
    requestParameters: NotificationsApiReadNotificationRequest,
    options?: AxiosRequestConfig
  ) {
    return NotificationsApiFp(this.configuration)
      .readNotification(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RatingCoursesApi - axios parameter creator
 * @export
 */
export const RatingCoursesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoint: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPoint', 'id', id);
      const localVarPath = `/api/rating-courses/{id}/point`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} courseId
     * @param {number} limit
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      courseId: number,
      limit: number,
      page: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('list', 'courseId', courseId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('list', 'limit', limit);
      // verify required parameter 'page' is not null or undefined
      assertParamExists('list', 'page', page);
      const localVarPath = `/api/rating-courses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (courseId !== undefined) {
        localVarQueryParameter['course_id'] = courseId;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RateDto} rateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rate: async (
      rateDto: RateDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rateDto' is not null or undefined
      assertParamExists('rate', 'rateDto', rateDto);
      const localVarPath = `/api/rating-courses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rateDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RatingCoursesApi - functional programming interface
 * @export
 */
export const RatingCoursesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RatingCoursesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoint(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RatingCoursesGetPoint200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPoint(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} courseId
     * @param {number} limit
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      courseId: number,
      limit: number,
      page: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RatingCoursesList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        courseId,
        limit,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {RateDto} rateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rate(
      rateDto: RateDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rate(
        rateDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RatingCoursesApi - factory interface
 * @export
 */
export const RatingCoursesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RatingCoursesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoint(
      id: number,
      options?: any
    ): AxiosPromise<RatingCoursesGetPoint200Response> {
      return localVarFp
        .getPoint(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} courseId
     * @param {number} limit
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      courseId: number,
      limit: number,
      page: number,
      options?: any
    ): AxiosPromise<RatingCoursesList200Response> {
      return localVarFp
        .list(courseId, limit, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RateDto} rateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rate(rateDto: RateDto, options?: any): AxiosPromise<void> {
      return localVarFp
        .rate(rateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPoint operation in RatingCoursesApi.
 * @export
 * @interface RatingCoursesApiGetPointRequest
 */
export interface RatingCoursesApiGetPointRequest {
  /**
   *
   * @type {number}
   * @memberof RatingCoursesApiGetPoint
   */
  readonly id: number;
}

/**
 * Request parameters for list operation in RatingCoursesApi.
 * @export
 * @interface RatingCoursesApiListRequest
 */
export interface RatingCoursesApiListRequest {
  /**
   *
   * @type {number}
   * @memberof RatingCoursesApiList
   */
  readonly courseId: number;

  /**
   *
   * @type {number}
   * @memberof RatingCoursesApiList
   */
  readonly limit: number;

  /**
   *
   * @type {number}
   * @memberof RatingCoursesApiList
   */
  readonly page: number;
}

/**
 * Request parameters for rate operation in RatingCoursesApi.
 * @export
 * @interface RatingCoursesApiRateRequest
 */
export interface RatingCoursesApiRateRequest {
  /**
   *
   * @type {RateDto}
   * @memberof RatingCoursesApiRate
   */
  readonly rateDto: RateDto;
}

/**
 * RatingCoursesApi - object-oriented interface
 * @export
 * @class RatingCoursesApi
 * @extends {BaseAPI}
 */
export class RatingCoursesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {RatingCoursesApiGetPointRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingCoursesApi
   */
  public getPoint(
    requestParameters: RatingCoursesApiGetPointRequest,
    options?: AxiosRequestConfig
  ) {
    return RatingCoursesApiFp(this.configuration)
      .getPoint(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RatingCoursesApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingCoursesApi
   */
  public list(
    requestParameters: RatingCoursesApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return RatingCoursesApiFp(this.configuration)
      .list(
        requestParameters.courseId,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RatingCoursesApiRateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingCoursesApi
   */
  public rate(
    requestParameters: RatingCoursesApiRateRequest,
    options?: AxiosRequestConfig
  ) {
    return RatingCoursesApiFp(this.configuration)
      .rate(requestParameters.rateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SectionsApi - axios parameter creator
 * @export
 */
export const SectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_delete', 'id', id);
      const localVarPath = `/api/sections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CreateSectionDto} createSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      createSectionDto: CreateSectionDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSectionDto' is not null or undefined
      assertParamExists('create', 'createSectionDto', createSectionDto);
      const localVarPath = `/api/sections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSectionDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {UpdateSectionDto} updateSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      id: number,
      updateSectionDto: UpdateSectionDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('update', 'id', id);
      // verify required parameter 'updateSectionDto' is not null or undefined
      assertParamExists('update', 'updateSectionDto', updateSectionDto);
      const localVarPath = `/api/sections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSectionDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SectionsApi - functional programming interface
 * @export
 */
export const SectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SectionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseDelete200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {CreateSectionDto} createSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      createSectionDto: CreateSectionDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SectionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        createSectionDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {UpdateSectionDto} updateSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      id: number,
      updateSectionDto: UpdateSectionDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SectionCreate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        id,
        updateSectionDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SectionsApi - factory interface
 * @export
 */
export const SectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SectionsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: any): AxiosPromise<CourseDelete200Response> {
      return localVarFp
        ._delete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CreateSectionDto} createSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      createSectionDto: CreateSectionDto,
      options?: any
    ): AxiosPromise<SectionCreate200Response> {
      return localVarFp
        .create(createSectionDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {UpdateSectionDto} updateSectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      id: number,
      updateSectionDto: UpdateSectionDto,
      options?: any
    ): AxiosPromise<SectionCreate200Response> {
      return localVarFp
        .update(id, updateSectionDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for _delete operation in SectionsApi.
 * @export
 * @interface SectionsApiDeleteRequest
 */
export interface SectionsApiDeleteRequest {
  /**
   *
   * @type {number}
   * @memberof SectionsApiDelete
   */
  readonly id: number;
}

/**
 * Request parameters for create operation in SectionsApi.
 * @export
 * @interface SectionsApiCreateRequest
 */
export interface SectionsApiCreateRequest {
  /**
   *
   * @type {CreateSectionDto}
   * @memberof SectionsApiCreate
   */
  readonly createSectionDto: CreateSectionDto;
}

/**
 * Request parameters for update operation in SectionsApi.
 * @export
 * @interface SectionsApiUpdateRequest
 */
export interface SectionsApiUpdateRequest {
  /**
   *
   * @type {number}
   * @memberof SectionsApiUpdate
   */
  readonly id: number;

  /**
   *
   * @type {UpdateSectionDto}
   * @memberof SectionsApiUpdate
   */
  readonly updateSectionDto: UpdateSectionDto;
}

/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
export class SectionsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {SectionsApiDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionsApi
   */
  public _delete(
    requestParameters: SectionsApiDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return SectionsApiFp(this.configuration)
      ._delete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SectionsApiCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionsApi
   */
  public create(
    requestParameters: SectionsApiCreateRequest,
    options?: AxiosRequestConfig
  ) {
    return SectionsApiFp(this.configuration)
      .create(requestParameters.createSectionDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SectionsApiUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SectionsApi
   */
  public update(
    requestParameters: SectionsApiUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return SectionsApiFp(this.configuration)
      .update(requestParameters.id, requestParameters.updateSectionDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TeachingRequestsApi - axios parameter creator
 * @export
 */
export const TeachingRequestsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accept: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('accept', 'id', id);
      const localVarPath = `/api/teaching-requests/accept/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('findOne', 'id', id);
      const localVarPath = `/api/teaching-requests/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      status: number,
      page: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'status' is not null or undefined
      assertParamExists('list', 'status', status);
      // verify required parameter 'page' is not null or undefined
      assertParamExists('list', 'page', page);
      const localVarPath = `/api/teaching-requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reject: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('reject', 'id', id);
      const localVarPath = `/api/teaching-requests/reject/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TeachingRequestDto} teachingRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    request: async (
      teachingRequestDto: TeachingRequestDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teachingRequestDto' is not null or undefined
      assertParamExists('request', 'teachingRequestDto', teachingRequestDto);
      const localVarPath = `/api/teaching-requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teachingRequestDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TeachingRequestsApi - functional programming interface
 * @export
 */
export const TeachingRequestsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TeachingRequestsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accept(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeachingRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accept(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findOne(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeachingRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      status: number,
      page: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeachingRequestList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        status,
        page,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reject(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeachingRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reject(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {TeachingRequestDto} teachingRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async request(
      teachingRequestDto: TeachingRequestDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeachingRequestRequest200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.request(
        teachingRequestDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TeachingRequestsApi - factory interface
 * @export
 */
export const TeachingRequestsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TeachingRequestsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accept(
      id: string,
      options?: any
    ): AxiosPromise<TeachingRequestRequest200Response> {
      return localVarFp
        .accept(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne(
      id: string,
      options?: any
    ): AxiosPromise<TeachingRequestRequest200Response> {
      return localVarFp
        .findOne(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} status
     * @param {number} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      status: number,
      page: number,
      options?: any
    ): AxiosPromise<TeachingRequestList200Response> {
      return localVarFp
        .list(status, page, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reject(
      id: string,
      options?: any
    ): AxiosPromise<TeachingRequestRequest200Response> {
      return localVarFp
        .reject(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TeachingRequestDto} teachingRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    request(
      teachingRequestDto: TeachingRequestDto,
      options?: any
    ): AxiosPromise<TeachingRequestRequest200Response> {
      return localVarFp
        .request(teachingRequestDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for accept operation in TeachingRequestsApi.
 * @export
 * @interface TeachingRequestsApiAcceptRequest
 */
export interface TeachingRequestsApiAcceptRequest {
  /**
   *
   * @type {string}
   * @memberof TeachingRequestsApiAccept
   */
  readonly id: string;
}

/**
 * Request parameters for findOne operation in TeachingRequestsApi.
 * @export
 * @interface TeachingRequestsApiFindOneRequest
 */
export interface TeachingRequestsApiFindOneRequest {
  /**
   *
   * @type {string}
   * @memberof TeachingRequestsApiFindOne
   */
  readonly id: string;
}

/**
 * Request parameters for list operation in TeachingRequestsApi.
 * @export
 * @interface TeachingRequestsApiListRequest
 */
export interface TeachingRequestsApiListRequest {
  /**
   *
   * @type {number}
   * @memberof TeachingRequestsApiList
   */
  readonly status: number;

  /**
   *
   * @type {number}
   * @memberof TeachingRequestsApiList
   */
  readonly page: number;
}

/**
 * Request parameters for reject operation in TeachingRequestsApi.
 * @export
 * @interface TeachingRequestsApiRejectRequest
 */
export interface TeachingRequestsApiRejectRequest {
  /**
   *
   * @type {string}
   * @memberof TeachingRequestsApiReject
   */
  readonly id: string;
}

/**
 * Request parameters for request operation in TeachingRequestsApi.
 * @export
 * @interface TeachingRequestsApiRequestRequest
 */
export interface TeachingRequestsApiRequestRequest {
  /**
   *
   * @type {TeachingRequestDto}
   * @memberof TeachingRequestsApiRequest
   */
  readonly teachingRequestDto: TeachingRequestDto;
}

/**
 * TeachingRequestsApi - object-oriented interface
 * @export
 * @class TeachingRequestsApi
 * @extends {BaseAPI}
 */
export class TeachingRequestsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {TeachingRequestsApiAcceptRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingRequestsApi
   */
  public accept(
    requestParameters: TeachingRequestsApiAcceptRequest,
    options?: AxiosRequestConfig
  ) {
    return TeachingRequestsApiFp(this.configuration)
      .accept(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TeachingRequestsApiFindOneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingRequestsApi
   */
  public findOne(
    requestParameters: TeachingRequestsApiFindOneRequest,
    options?: AxiosRequestConfig
  ) {
    return TeachingRequestsApiFp(this.configuration)
      .findOne(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TeachingRequestsApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingRequestsApi
   */
  public list(
    requestParameters: TeachingRequestsApiListRequest,
    options?: AxiosRequestConfig
  ) {
    return TeachingRequestsApiFp(this.configuration)
      .list(requestParameters.status, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TeachingRequestsApiRejectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingRequestsApi
   */
  public reject(
    requestParameters: TeachingRequestsApiRejectRequest,
    options?: AxiosRequestConfig
  ) {
    return TeachingRequestsApiFp(this.configuration)
      .reject(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TeachingRequestsApiRequestRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingRequestsApi
   */
  public request(
    requestParameters: TeachingRequestsApiRequestRequest,
    options?: AxiosRequestConfig
  ) {
    return TeachingRequestsApiFp(this.configuration)
      .request(requestParameters.teachingRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TopicsApi - axios parameter creator
 * @export
 */
export const TopicsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} [c]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAll: async (
      c?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/topics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (c !== undefined) {
        localVarQueryParameter['c'] = c;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne: async (
      slug: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slug' is not null or undefined
      assertParamExists('findOne', 'slug', slug);
      const localVarPath = `/api/topics/{slug}`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TopicsApi - functional programming interface
 * @export
 */
export const TopicsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TopicsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [c]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findAll(
      c?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TopicFindAll200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(
        c,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findOne(
      slug: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TopicFindOne200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(
        slug,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TopicsApi - factory interface
 * @export
 */
export const TopicsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TopicsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [c]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAll(c?: number, options?: any): AxiosPromise<TopicFindAll200Response> {
      return localVarFp
        .findAll(c, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findOne(
      slug: string,
      options?: any
    ): AxiosPromise<TopicFindOne200Response> {
      return localVarFp
        .findOne(slug, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for findAll operation in TopicsApi.
 * @export
 * @interface TopicsApiFindAllRequest
 */
export interface TopicsApiFindAllRequest {
  /**
   *
   * @type {number}
   * @memberof TopicsApiFindAll
   */
  readonly c?: number;
}

/**
 * Request parameters for findOne operation in TopicsApi.
 * @export
 * @interface TopicsApiFindOneRequest
 */
export interface TopicsApiFindOneRequest {
  /**
   *
   * @type {string}
   * @memberof TopicsApiFindOne
   */
  readonly slug: string;
}

/**
 * TopicsApi - object-oriented interface
 * @export
 * @class TopicsApi
 * @extends {BaseAPI}
 */
export class TopicsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {TopicsApiFindAllRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TopicsApi
   */
  public findAll(
    requestParameters: TopicsApiFindAllRequest = {},
    options?: AxiosRequestConfig
  ) {
    return TopicsApiFp(this.configuration)
      .findAll(requestParameters.c, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TopicsApiFindOneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TopicsApi
   */
  public findOne(
    requestParameters: TopicsApiFindOneRequest,
    options?: AxiosRequestConfig
  ) {
    return TopicsApiFp(this.configuration)
      .findOne(requestParameters.slug, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _public: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/users/public`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacher: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/users/teacher`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      q?: string,
      page?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/users/profile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {UserUpdateDto} userUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      userUpdateDto: UserUpdateDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userUpdateDto' is not null or undefined
      assertParamExists('update', 'userUpdateDto', userUpdateDto);
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdateDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _public(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserPublic200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._public(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTeacher(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserGetTeacher200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacher(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      q?: string,
      page?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserList200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        q,
        page,
        limit,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profile(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserUpdate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profile(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary
     * @param {UserUpdateDto} userUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      userUpdateDto: UserUpdateDto,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserUpdate200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        userUpdateDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _public(options?: any): AxiosPromise<UserPublic200Response> {
      return localVarFp
        ._public(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacher(options?: any): AxiosPromise<UserGetTeacher200Response> {
      return localVarFp
        .getTeacher(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      q?: string,
      page?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<UserList200Response> {
      return localVarFp
        .list(q, page, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profile(options?: any): AxiosPromise<UserUpdate200Response> {
      return localVarFp
        .profile(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {UserUpdateDto} userUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      userUpdateDto: UserUpdateDto,
      options?: any
    ): AxiosPromise<UserUpdate200Response> {
      return localVarFp
        .update(userUpdateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for list operation in UsersApi.
 * @export
 * @interface UsersApiListRequest
 */
export interface UsersApiListRequest {
  /**
   *
   * @type {string}
   * @memberof UsersApiList
   */
  readonly q?: string;

  /**
   *
   * @type {number}
   * @memberof UsersApiList
   */
  readonly page?: number;

  /**
   *
   * @type {number}
   * @memberof UsersApiList
   */
  readonly limit?: number;
}

/**
 * Request parameters for update operation in UsersApi.
 * @export
 * @interface UsersApiUpdateRequest
 */
export interface UsersApiUpdateRequest {
  /**
   *
   * @type {UserUpdateDto}
   * @memberof UsersApiUpdate
   */
  readonly userUpdateDto: UserUpdateDto;
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public _public(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      ._public(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getTeacher(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getTeacher(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {UsersApiListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public list(
    requestParameters: UsersApiListRequest = {},
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .list(
        requestParameters.q,
        requestParameters.page,
        requestParameters.limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public profile(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .profile(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {UsersApiUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public update(
    requestParameters: UsersApiUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .update(requestParameters.userUpdateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
